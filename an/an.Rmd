---
title: "[eb1] Measurement - Quality Control"
author: "Egor Ananyev"
date: "2019-01-04"
output:
    html_document:
        toc: true
editor_options: 
  chunk_output_type: console
---

<style type="text/css">
body, td{
  font-family: Cambria;
}
code.r{
  font-family: Inconsolata;
}
</style>

# Data input and parsing
```{r set-options, message=F}
options(width=100)
shocky = T
library(plyr)
extrafont::loadfonts(device='win')
font_import(paths = NULL, recursive = TRUE, prompt = TRUE,pattern = NULL)
library(ggplot2)
dropbox_dir='/Users/Egor/Dropbox/'
data_dir = paste(dropbox_dir, 'Projects/pm/data/pm1/', sep='/')
subjs = dir(data_dir, pattern='subj-')
ds = data.frame()
# cur_subj = subjs  # temp
for(cur_subj in subjs){
  cur_subj_dir = paste0(data_dir, cur_subj)
  blocks = dir(cur_subj_dir, pattern='block-')
  # cur_block = blocks  # temp
  for(cur_block in blocks){
    cur_ds = read.csv(paste(paste(cur_subj_dir, cur_block, sep='/'), 'beh_out.csv', sep='/'))
    # ds = cur_ds  # temp
    ds = rbind(ds, cur_ds)
  }
}
rm(blocks, cur_block, cur_subj, cur_ds, cur_subj_dir, shocky)
head(ds)
```

# Visualization

## Confidence ratings
```{r}
# ```{r, fig.width=3, fig.height=2.5}
# print(colnames(ds))  # debug
ds_conf = ds
ds_conf = ddply(ds_conf, .(subj, resp_int_conf, stim1_c, stim2_c), summarise, 
                count=length(resp_int_conf))
p = ggplot(data=ds_conf, aes(x=factor(stim1_c), y=count, fill=factor(resp_int_conf))) + 
  facet_grid(cols=vars(stim2_c)) + geom_bar(stat='identity') + 
  labs(fill='Confidence', x='Stimulus Contrasts') + theme(legend.position='top')
print(p)
rm(ds_conf, p)
```

## Cueing
```{r}
for(cur_subj in subjs){
  for(cur_cond in c('a','c','v')){
    cur_ds = ds[ds$cond==cur_cond & ds$subj==as.numeric(substring(cur_subj, 6, 7)),]
    cur_cond_name = unique(cur_ds$CondFull)
    p = ggplot(data=cur_ds, aes(x=factor(cue_valid), y=rt))
    p = p + theme_bw() + ylim(short_rt_cutoff, .9)
    p = p + geom_dotplot(binaxis='y', stackdir='center', dotsize=1, binwidth=.02)
    p = p + ggtitle(paste('cond', cur_cond_name))
    suppressWarnings(plot(p))
  }
}
```

```{r, fig.width=3, fig.height=2.5}
for(cur_subj in subjs){
    for(cur_cond in c('a','c','v')){
      cur_ds = ds[ds$cond==cur_cond & ds$subj==as.numeric(substring(cur_subj, 6, 7)),]
      cur_cond_name = unique(cur_ds$CondFull)
      p = ggplot(data=cur_ds, aes(x=rt, colour=factor(cue_valid))) + geom_density() +
        theme(legend.position = 'bottom') + ggtitle(paste('cond', cur_cond_name))
      plot(p)
    }
}
```

# Analyses
```{r}
# Reordering levels of Condition variable, such that No Blink condition is the reference:
ds$Cond <- factor(ds$Cond, c('NoBlink','Artificial','Prompted')) #this works for lm
summary(lm(rt~Cond*cue_valid, data=ds))  # switch to lme4 for mixed models
# 1 / generalTestBF(rt ~ cond*cue_valid, data=ds, whichModels='top')
```

# Predicting necessary N
```{r}
obt_eff = 0.026
obt_se = 0.015

# Function for retrieving the BFs associated with different Ns:
bf_N = function(base_eff, base_ssd, tails=2){  # base_ssd = the sum of squared difference
  # BF_U(LL, UL, meanobtained, semobtained, dfobtained)
  bfs = c()
  for(cur_N in 2:40){
    if(tails==1)  # one-tailed
      { bfs = c(bfs, BF_U(0, .03, base_eff, base_ssd/sqrt(cur_N), cur_N-1)) }
    else  # two-tailed
      { bfs = c(bfs, BF_U(-0.03, .03, base_eff, base_ssd/sqrt(cur_N), cur_N-1)) }
  }
  # print(bfs)
  return(bfs)
}

# Function for retrieving the minimum N at which a significant BF is achieved
# (assuming alternative is true):
min_N = function(eff, ssd, tails=1){ 
  min(which(bf_N(eff, ssd, tails)>3))+1
}

## At which N does the BF achieve significance?

# At first, testing one-tailed hypothesis:
min_N(obt_eff, obt_se * 1.0)  # at SSD of one (assuming the least noisy SE)
min_N(obt_eff, obt_se * 1.5)  # at SSD 1.5 times the minimum SSD
min_N(obt_eff, obt_se * 2.0)  # twice the minimum SSD

# Testing a two-tailed hypothesis:
# At which N does the BF achieve significance?
min_N(obt_eff, obt_se * 1.0, 2)  # at SSD of one (assuming the least noisy SE)
min_N(obt_eff, obt_se * 1.5, 2)  # at SSD 1.5 times the minimum SSD
min_N(obt_eff, obt_se * 2.0, 2)  # twice the minimum SSD
```